<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ASTRI NASCENTI ‚Äî Book (mobile-ready) ‚Äî Debug</title>
<style>
  html,body{margin:0;height:100%;background:#0b0b0b;color:#fff;font-family:system-ui,Arial}
  .wrap{min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:16px;box-sizing:border-box}
  .book{width:min(92vw,520px);aspect-ratio:13/18;position:relative;perspective:1800px}
  .viewport{width:100%;height:100%;position:relative;overflow:hidden;background:#111;border-radius:8px;box-shadow:0 30px 80px rgba(0,0,0,.8);touch-action:pan-y}
  .layer{position:absolute;inset:0;backface-visibility:hidden;transform-style:preserve-3d}
  .layer img{width:100%;height:100%;object-fit:cover;user-select:none;-webkit-user-drag:none;display:block}
  .next{z-index:1}
  .flipper{transform-origin:left center;transition:transform .85s cubic-bezier(.2,.9,.2,1);z-index:2}
  .flipper.turn{transform:rotateY(-180deg)}
  .flipper .back{position:absolute;inset:0;transform:rotateY(180deg);backface-visibility:hidden}
  .controls{margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:center}
  button{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.25);color:#fff;padding:10px 16px;font-size:15px;border-radius:10px;cursor:pointer}
  button:hover{background:rgba(255,255,255,.18)}
  .status{font-size:14px;opacity:.9}
  .debug{width:min(92vw,720px);margin-top:14px;background:#0f1720;border-radius:8px;padding:12px;color:#cbd5e1;font-size:13px;max-height:220px;overflow:auto;box-shadow:0 10px 30px rgba(0,0,0,.6)}
  .debug h4{margin:0 0 8px 0;color:#fff;font-size:14px}
  .debug .line{font-family:monospace;white-space:pre-wrap;margin-bottom:6px}
  .missing{opacity:.6;filter:grayscale(60%)}
  @media (hover:none) and (pointer:coarse){button{padding:14px 18px;font-size:17px}}
</style>
</head>
<body>
<div class="wrap">
  <div class="book">
    <div class="viewport" id="viewport">
      <div class="layer next"><img id="nextImg" alt="pagina sotto"></div>
      <div class="layer flipper" id="flipper">
        <img id="currentImg" alt="pagina corrente">
        <div class="back"><img id="backImg" alt="retro pagina"></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <button id="prev">‚óÄ Indietro</button>
    <div class="status" id="status">1 / 36</div>
    <button id="next">Avanti ‚ñ∂</button>
    <button id="recheck">üîÅ Riprova PATH</button>
  </div>

  <div class="debug" id="debug">
    <h4>Debug: verifica accesso immagini</h4>
    <div id="debugLines"></div>
  </div>
</div>

<script>
/* CONFIG */
const TOTAL = 36; // numero di file attesi (1..36)
let PATH = 'astri-nascenti/introduzione-astronomia/pag/astri-nascenti-2025-'; // valore iniziale suggerito
const EXT = '.jpg';

/* Candidate path variations da provare automaticamente */
const CANDIDATE_PREFIXES = [
  'astri-nascenti/introduzione-astronomia/pag/astri-nascenti-2025-',
  './astri-nascenti/introduzione-astronomia/pag/astri-nascenti-2025-',
  '/astri-nascenti/introduzione-astronomia/pag/astri-nascenti-2025-',
  'astri-nascenti/introduzione-astronomia/pag/Pag/astri-nascenti-2025-',
  'Pag/astri-nascenti-2025-',
  'pag/astri-nascenti-2025-',
  './astri-nascenti/introduzione-astronomia/pag/astri-nascenti-2025-' // ripetuto per sicurezza
];

/* elementi DOM */
const currentImg = document.getElementById('currentImg');
const nextImg = document.getElementById('nextImg');
const backImg = document.getElementById('backImg');
const flipper = document.getElementById('flipper');
const status = document.getElementById('status');
const viewport = document.getElementById('viewport');
const debugLines = document.getElementById('debugLines');

let index = 1;
let busy = false;
let flipping = false;

/* Placeholder SVG (data URI) per file mancante */
const PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(
  `<svg xmlns="http://www.w3.org/2000/svg" width="800" height="1100">
     <rect width="100%" height="100%" fill="#111"/>
     <text x="50%" y="50%" fill="#888" font-size="36" font-family="Arial" dominant-baseline="middle" text-anchor="middle">
       Immagine non trovata
     </text>
     <text x="50%" y="60%" fill="#555" font-size="18" font-family="Arial" dominant-baseline="middle" text-anchor="middle">
       Controlla percorso / server
     </text>
   </svg>`
);

/* helper per scrivere debug */
function debug(msg){
  const div = document.createElement('div');
  div.className = 'line';
  div.textContent = `[${(new Date()).toLocaleTimeString()}] ${msg}`;
  debugLines.prepend(div);
  console.log(msg);
}

/* costruisce URL per pagina n con prefisso p */
const urlFor = (p, n) => `${p}${n}${EXT}`;

/* prova a verificare esistenza immagine usando HEAD; se fallisce (CORS), usa Image loader fallback */
async function checkUrl(url){
  try{
    // prova HEAD per non scaricare immagine intera
    const res = await fetch(url, {method:'HEAD'});
    if(res.ok){ return {ok:true, status:res.status, url}; }
    // se HEAD fallisce con status (404, 403) ritorna comunque l'oggetto
    return {ok:false, status:res.status, url};
  }catch(err){
    // pu√≤ fallire per CORS o per rete -> fallback con Image()
    return new Promise(resolve=>{
      const img = new Image();
      let settled = false;
      img.onload = ()=>{ if(!settled){ settled=true; resolve({ok:true, status:200, url}); } };
      img.onerror = ()=>{ if(!settled){ settled=true; resolve({ok:false, status:0, url}); } };
      img.src = url;
      // timeout di sicurezza 4s
      setTimeout(()=>{ if(!settled){ settled=true; resolve({ok:false, status:0, url}); } }, 4000);
    });
  }
}

/* tenta di trovare un prefix funzionante tra i candidati */
async function autodetectPath(){
  debug('Avvio autodetect PATH ‚Äî provo varie alternative...');
  for(const p of CANDIDATE_PREFIXES){
    // proviamo su alcuni indici: 1, 2 e l'ultimo (36) per avere copertura
    const tests = [1, Math.min(2, TOTAL), TOTAL].filter((v,i,arr)=>arr.indexOf(v) === i);
    let okAny = false;
    for(const n of tests){
      const u = urlFor(p, n);
      debug(`Provo: ${u}`);
      // eslint-disable-next-line no-await-in-loop
      const result = await checkUrl(u);
      debug(` ‚Üí ${result.ok ? 'OK' : 'MANCANTE'} (${result.status || 'no-status'})`);
      if(result.ok){ okAny = true; break; }
    }
    if(okAny){
      debug(`Selezionato PATH funzionante: "${p}"`);
      return p;
    }
  }
  debug('Nessun PATH tra i candidati risulta raggiungibile. Verifica che i file siano serviti via HTTP dallo stesso host o che il server permetta richieste CORS.');
  return null;
}

/* src wrapper basato su PATH globale */
const src = i => {
  const n = Math.max(1, Math.min(TOTAL, i));
  return `${PATH}${n}${EXT}`;
};

/* preload che prova a caricare immagine (ritorna sempre) */
function preload(n){
  return new Promise(r=>{
    const img = new Image();
    img.onload = ()=>r(true);
    img.onerror = ()=>r(false);
    img.src = `${PATH}${n}${EXT}`;
  });
}

function renderImmediate(){
  currentImg.classList.remove('missing');
  nextImg.classList.remove('missing');
  backImg.classList.remove('missing');

  currentImg.src = src(index);
  const nextIndex = Math.min(index + 1, TOTAL);
  backImg.src = src(nextIndex);
  nextImg.src = src(nextIndex);
  status.textContent = `${index} / ${TOTAL}`;
}

/* gestione errore immagine: mostra placeholder e marca come missing */
function onImgError(e){
  const img = e.currentTarget;
  img.src = PLACEHOLDER;
  img.classList.add('missing');
  debug(`Immagine mancante: ${img.getAttribute('data-debug-url') || img.src}`);
}

/* imposta attributo debug-url per track */
function setDebugAttr(imgEl, url){
  try{ imgEl.setAttribute('data-debug-url', url); }catch(e){}
}

/* funzione flip next/prev (uguali a prima) */
function next(){
  if(busy || index >= TOTAL) return;
  busy = true;
  flipping = true;
  const target = index + 1;
  Promise.all([preload(index), preload(target)]).then(()=>{
    backImg.src = src(target);
    nextImg.src = src(target);
    // set debug attrs
    setDebugAttr(currentImg, src(index));
    setDebugAttr(backImg, src(target));
    setDebugAttr(nextImg, src(target));
    flipper.classList.add('turn');
  }).catch(()=>{
    backImg.src = src(target);
    nextImg.src = src(target);
    setDebugAttr(backImg, src(target));
    setDebugAttr(nextImg, src(target));
    flipper.classList.add('turn');
  });
}

function onTransitionEnd(e){
  if(!flipping) return;
  if(e.propertyName !== 'transform') return;
  flipping = false;
  index = Math.min(index + 1, TOTAL);
  const prevTransition = flipper.style.transition;
  flipper.style.transition = 'none';
  flipper.classList.remove('turn');
  currentImg.src = src(index);
  const nextIndex = Math.min(index + 1, TOTAL);
  backImg.src = src(nextIndex);
  nextImg.src = src(nextIndex);
  status.textContent = `${index} / ${TOTAL}`;
  void flipper.offsetWidth;
  requestAnimationFrame(()=> {
    flipper.style.transition = prevTransition || 'transform 0.85s cubic-bezier(.2,.9,.2,1)';
    busy = false;
  });
}

function prev(){
  if(busy || index <= 1) return;
  busy = true;
  index = Math.max(1, index - 1);
  currentImg.src = src(index);
  const nextIndex = Math.min(index + 1, TOTAL);
  backImg.src = src(nextIndex);
  nextImg.src = src(nextIndex);
  status.textContent = `${index} / ${TOTAL}`;
  setTimeout(()=> busy = false, 150);
}

/* attach events */
document.getElementById('next').onclick = next;
document.getElementById('prev').onclick = prev;
document.getElementById('recheck').onclick = async () => {
  document.getElementById('recheck').disabled = true;
  debug('Forzo nuova ricerca PATH...');
  const found = await autodetectPath();
  if(found){ PATH = found; debug('PATH aggiornato a: ' + PATH); renderImmediate(); }
  document.getElementById('recheck').disabled = false;
};
flipper.addEventListener('transitionend', onTransitionEnd);
[currentImg, nextImg, backImg].forEach(img => {
  img.addEventListener('error', onImgError);
});

/* touch & click (sintetico, come prima) */
(function enableTouch(){
  let touchStartX=0, touchStartY=0, touchLastX=0, touchLastY=0, touchStartTime=0, isDragging=false;
  const THRESHOLD = 40;
  viewport.addEventListener('touchstart', (ev)=>{ if(ev.touches.length>1) return; touchStartX = touchLastX = ev.touches[0].clientX; touchStartY = touchLastY = ev.touches[0].clientY; touchStartTime = Date.now(); isDragging=false; }, {passive:true});
  viewport.addEventListener('touchmove', (ev)=>{ if(ev.touches.length>1) return; const dx = ev.touches[0].clientX - touchStartX; const dy = ev.touches[0].clientY - touchStartY; touchLastX = ev.touches[0].clientX; touchLastY = ev.touches[0].clientY; if(Math.abs(dx)>10 && Math.abs(dx)>Math.abs(dy)){ isDragging=true; ev.preventDefault(); } }, {passive:false});
  viewport.addEventListener('touchend', (ev)=>{ const dx = touchLastX - touchStartX; const dy = touchLastY - touchStartY; const dt = Date.now() - touchStartTime; if(isDragging && Math.abs(dx)>THRESHOLD && Math.abs(dx)>Math.abs(dy)){ if(dx<0) next(); else prev(); } else { if(dt<300 && Math.abs(dx)<12 && Math.abs(dy)<12){ const rect=viewport.getBoundingClientRect(); const tapX = touchLastX || touchStartX; const relativeX = tapX - rect.left; if(relativeX > rect.width/2) next(); else prev(); } } isDragging=false; }, {passive:true});
  viewport.addEventListener('click', (ev)=>{ const rect = viewport.getBoundingClientRect(); const x = ev.clientX - rect.left; if(x > rect.width/2) next(); else prev(); });
})();

/* INIT: autodetect PATH, poi render */
(async function init(){
  debug('Inizializzazione: provo a rilevare il PATH corretto e a caricare le prime immagini...');
  const detected = await autodetectPath();
  if(detected){ PATH = detected; debug('PATH impostato a: ' + PATH); }
  else { debug('Attenzione: non √® stato trovato PATH funzionante. Se i file sono su un NAS locale, assicurati che siano serviti via HTTP (es. http://tuo-host/...).'); }
  // imposto attributi debug sulle immagini correnti
  setDebugAttr(currentImg, src(1));
  setDebugAttr(backImg, src(2));
  setDebugAttr(nextImg, src(2));
  // preload e render
  await Promise.all([preload(1), preload(2)]);
  renderImmediate();
})();
</script>
</body>
</html>
