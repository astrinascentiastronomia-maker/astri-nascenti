<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ASTRI NASCENTI — Book (mobile-ready)</title>

<style>
html,body{
  margin:0;
  height:100%;
  background:#0b0b0b;
  color:#fff;
  font-family:system-ui, Arial;
}

/* CONTENITORE */
.wrap{
  min-height:100vh;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:24px 12px;
  box-sizing:border-box;
}

/* LIBRO: dimensioni responsive */
.book{
  /* width constrained to viewport on mobile but never larger than original */
  width: min(92vw, 520px);
  /* preserve original aspect ratio 520:720 -> 13:18 */
  aspect-ratio: 13 / 18;
  height: auto;
  position:relative;
  perspective:1800px;
}

/* FINESTRA PAGINA */
.viewport{
  width:100%;
  height:100%;
  position:relative;
  overflow:hidden;
  background:#111;
  box-shadow:0 30px 80px rgba(0,0,0,.8);
  border-radius:8px;
  touch-action: pan-y; /* permette lo scrolling verticale ma ci dà il controllo sugli swipe orizzontali */
}

/* STRATI */
.layer{
  position:absolute;
  inset:0;
  backface-visibility:hidden;
  transform-style:preserve-3d;
}

/* IMMAGINI */
.layer img{
  width:100%;
  height:100%;
  object-fit:cover;
  user-select:none;
  -webkit-user-drag:none;
  display:block;
}

/* PAGINA SOTTO (GIÀ ATTACCATA) */
.next{
  z-index:1;
}

/* PAGINA CHE GIRA */
.flipper{
  transform-origin:left center;
  transition:transform 0.85s cubic-bezier(.2,.9,.2,1);
  z-index:2;
}

/* STATO ANIMAZIONE */
.flipper.turn{
  transform:rotateY(-180deg);
}

/* RETRO DELLA PAGINA */
.flipper .back{
  position:absolute;
  inset:0;
  transform:rotateY(180deg);
  backface-visibility:hidden;
}

/* CONTROLLI */
.controls{
  margin-top:16px;
  display:flex;
  gap:12px;
  align-items:center;
  flex-wrap:wrap;
  justify-content:center;
}

button{
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.25);
  color:#fff;
  padding:10px 18px;
  font-size:15px;
  border-radius:10px;
  cursor:pointer;
}

button:hover{
  background:rgba(255,255,255,.18);
}

.status{
  font-size:14px;
  opacity:.85;
}

/* piccoli ritocchi touch-friendly */
@media (hover:none) and (pointer:coarse){
  button{ padding:14px 20px; font-size:17px; }
}
</style>
</head>

<body>

<div class="wrap">

  <div class="book">
    <div class="viewport" id="viewport">

      <!-- PAGINA SUCCESSIVA (GIÀ ATTACCATA SOTTO) -->
      <div class="layer next">
        <img id="nextImg" alt="pagina sotto">
      </div>

      <!-- PAGINA CHE GIRA -->
      <div class="layer flipper" id="flipper">
        <img id="currentImg" alt="pagina corrente">
        <div class="back">
          <img id="backImg" alt="retro pagina">
        </div>
      </div>

    </div>
  </div>

  <div class="controls">
    <button id="prev">◀ Indietro</button>
    <div class="status" id="status">1 / 36</div>
    <button id="next">Avanti ▶</button>
  </div>

</div>

<script>
/* CONFIGURAZIONE */
const TOTAL = 36;
const PATH  = 'Pag/astri-nascenti-2025-';
const EXT   = '.jpg';

const currentImg = document.getElementById('currentImg');
const nextImg    = document.getElementById('nextImg');
const backImg    = document.getElementById('backImg');
const flipper    = document.getElementById('flipper');
const status     = document.getElementById('status');
const viewport   = document.getElementById('viewport');

let index = 1;           // pagina corrente (1-based)
let busy  = false;       // blocco animazioni
let flipping = false;    // stato flip in corso

const src = i => `${PATH}${i}${EXT}`;

/* PRELOAD UTILE: assicura immagine pronta */
function preload(n){
  return new Promise(r=>{
    const img = new Image();
    img.onload = img.onerror = r;
    img.src = src(n);
  });
}

/* CARICA VISUALIZZAZIONE ATTUALE (senza animazione) */
function renderImmediate(){
  currentImg.src = src(index);
  // backImg e nextImg mostrano la pagina successiva (duplicata per continuità visiva)
  const nextIndex = Math.min(index + 1, TOTAL);
  backImg.src    = src(nextIndex);
  nextImg.src    = src(nextIndex);
  status.textContent = `${index} / ${TOTAL}`;
}

/* PROCEDURA DI FLIP AVANTI (senza rimbalzo)
   - aggiunge classe 'turn' per avviare la rotazione
   - attende 'transitionend' per aggiornare gli src senza animazione visibile
*/
function next(){
  if(busy || index >= TOTAL) return;
  busy = true;
  flipping = true;

  // assicurati che le immagini da mostrare siano caricate (preload)
  const target = index + 1;
  Promise.all([preload(index), preload(target)]).then(()=>{
    // metti il retro (backImg) con la pagina di destinazione - già fatto dal preload
    backImg.src = src(target);
    nextImg.src = src(target);

    // start animation
    flipper.classList.add('turn');
    // il resto è gestito dall'evento transitionend
  });
}

/* Gestione fine transizione: aggiorna stato senza mostrare flip-back */
function onTransitionEnd(e){
  if(!flipping) return;
  if(e.propertyName !== 'transform') return;

  flipping = false;
  index = Math.min(index + 1, TOTAL);

  // disabilita transizione del flipper per il reset visivo
  const prevTransition = flipper.style.transition;
  flipper.style.transition = 'none';

  flipper.classList.remove('turn');

  // aggiorna le immagini immediate alla nuova pagina corrente
  currentImg.src = src(index);
  const nextIndex = Math.min(index + 1, TOTAL);
  backImg.src    = src(nextIndex);
  nextImg.src    = src(nextIndex);
  status.textContent = `${index} / ${TOTAL}`;

  // forziamo reflow per essere sicuri
  void flipper.offsetWidth;

  // ripristiniamo la transizione al valore originale dopo un frame
  requestAnimationFrame(()=> {
    flipper.style.transition = prevTransition || 'transform 0.85s cubic-bezier(.2,.9,.2,1)';
    busy = false;
  });
}

/* INDIETRO: semplice decremento senza animazione di ritorno */
function prev(){
  if(busy || index <= 1) return;
  busy = true;

  index = Math.max(1, index - 1);
  currentImg.src = src(index);
  const nextIndex = Math.min(index + 1, TOTAL);
  backImg.src    = src(nextIndex);
  nextImg.src    = src(nextIndex);
  status.textContent = `${index} / ${TOTAL}`;

  setTimeout(()=> busy = false, 150);
}

/* EVENTI BOTTONI */
document.getElementById('next').onclick = next;
document.getElementById('prev').onclick = prev;
flipper.addEventListener('transitionend', onTransitionEnd);

/* TOUCH / SWIPE SUPPORT (mobile)
   - swipe left => next
   - swipe right => prev
   - tap right half => next, left half => prev (short tap)
*/
(function enableTouch(){
  let touchStartX = 0;
  let touchStartY = 0;
  let touchLastX = 0;
  let touchLastY = 0;
  let touchStartTime = 0;
  let isDragging = false;

  const THRESHOLD = 40; // px minimo per considerare swipe

  viewport.addEventListener('touchstart', (ev)=>{
    if(ev.touches.length > 1) return; // ignora pinch
    touchStartX = touchLastX = ev.touches[0].clientX;
    touchStartY = touchLastY = ev.touches[0].clientY;
    touchStartTime = Date.now();
    isDragging = false;
  }, {passive:true});

  viewport.addEventListener('touchmove', (ev)=>{
    if(ev.touches.length > 1) return;
    const dx = ev.touches[0].clientX - touchStartX;
    const dy = ev.touches[0].clientY - touchStartY;
    touchLastX = ev.touches[0].clientX;
    touchLastY = ev.touches[0].clientY;

    // se il movimento è principalmente orizzontale, impediamo lo scroll verticale predefinito
    if(Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)){
      isDragging = true;
      // impediamo lo scorrimento orizzontale nativo (se possibile)
      ev.preventDefault();
    }
  }, {passive:false});

  viewport.addEventListener('touchend', (ev)=>{
    const dx = touchLastX - touchStartX;
    const dy = touchLastY - touchStartY;
    const dt = Date.now() - touchStartTime;

    if(isDragging && Math.abs(dx) > THRESHOLD && Math.abs(dx) > Math.abs(dy)){
      if(dx < 0) {
        next();
      } else {
        prev();
      }
    } else {
      // breve tap (pochi ms e poco spostamento) -> consideriamo tap su metà viewport
      if(dt < 300 && Math.abs(dx) < 12 && Math.abs(dy) < 12){
        const rect = viewport.getBoundingClientRect();
        const tapX = touchLastX || touchStartX;
        const relativeX = tapX - rect.left;
        if(relativeX > rect.width / 2){
          next();
        } else {
          prev();
        }
      }
    }

    isDragging = false;
  }, {passive:true});

  // per comodità: supporto anche per mouse (drag o click sulle metà)
  viewport.addEventListener('click', (ev)=>{
    const rect = viewport.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    if(x > rect.width / 2) next(); else prev();
  });

})();

/* INIZIALIZZAZIONE */
(function init(){
  // preload primo e secondo per evitare flicker
  Promise.all([preload(1), preload(2)]).then(()=>{
    renderImmediate();
  });
})();
</script>

</body>
</html>
